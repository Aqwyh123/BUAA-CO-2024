# Verilog MIPS 五级流水线 CPU

## 一、设计草稿

功能模块： IFU、GRF、EXT、CMP、NPC、ALU、DM、Control 和 HazardControl。
流水线寄存器：ID_REG、DE_REG、EM_REG、MW_REG。

采用分布式译码，但集中处理险情。
未设计各类专用 MUX，直接使用 assign 搭配三元运算符或 always 行为级建模。

对于阻塞，采用“暴力阻塞”。
将需要阻塞的指令阻塞在 D 级，行为是阻塞 PC 和 FD_REG，并清空DE_REG（插入 nop）。
Unlikely 分支指令支持延迟槽，需要注意测试数据的编写。
Likely 分支指令可能清空延迟槽，需要注意测试数据的编写，以及阻塞时分支条件未计算完成，应等待阻塞结束再使清空信号生效。

对于转发数据的接收，根据 HazardControl 对每一级生成的接收信号，控制接收来自哪一级的转发。
对于转发数据的发送，采用全力转发的形式，根据指令类型，无论是否需要，都要全力转发。

与前几 P 不同的是，对于lui 指令，EXT 拓展结果不经 ALU 按位或 0，直接看作计算完成，防止阻塞，提高效率。

### （一）F 级

#### 1. IFU

##### （1）整体结构

| 信号名  | 方向 |    类型     |     描述     |
| :-----: | :--: | :---------: | :----------: |
|   clk   |  I   |    wire     |   时钟信号   |
|  reset  |  I   |    wire     | 同步复位信号 |
|  stall  |  I   |    wire     |   阻塞信号   |
| next_PC |  I   | wire [31:0] | 下一指令地址 |
|   PC    |  O   | wire [31:0] | 当前指令地址 |
|  instr  |  O   | wire [31:0] |     指令     |

起始地址：0x00003000
地址范围：0x00003000 ~ 0x00006FFF
存储容量：$4096 * 32bit = 16KiB$

阻塞信号为高电平时，忽略输入，内部寄存器保持一个时钟周期。

非法地址输出未定值，无指令地址输出 0。

##### （2）内部模块

###### ① PC

| 信号名  | 方向 |    类型     |     描述     |
| :-----: | :--: | :---------: | :----------: |
|   clk   |  I   |    wire     |   时钟信号   |
|  reset  |  I   |    wire     | 同步复位信号 |
|  stall  |  I   |    wire     |   阻塞信号   |
| next_PC |  I   | wire [31:0] | 下一指令地址 |
|   PC    |  O   | wire [31:0] | 当前指令地址 |

阻塞信号为高电平时，忽略输入，内部寄存器保持一个时钟周期。

###### ② IM

| 信号名 | 方向 |    类型     |   描述   |
| :----: | :--: | :---------: | :------: |
|  addr  |  I   | wire [31:0] | 指令地址 |
| instr  |  O   | wire [31:0] |   指令   |

起始地址：0x00003000
地址范围：0x00003000 ~ 0x00006FFF
存储容量：$4096 * 32bit = 12KiB$

非法地址输出未定值，无指令地址输出 0。

### （二）D 级

FD 流水线寄存器

| 信号名  | 方向 |    类型     |     描述     |
| :-----: | :--: | :---------: | :----------: |
|   clk   |  I   |    wire     |   时钟信号   |
|  reset  |  I   |    wire     | 同步复位信号 |
|  stall  |  I   |    wire     |   阻塞信号   |
|  flush  |  I   |    wire     |   刷新信号   |
|  F_PC   |  I   | wire [31:0] |   F 级 PC    |
| F_instr |  I   | wire [31:0] |   F 级指令   |
|  D_PC   |  O   | wire [31:0] |   D 级 PC    |
| D_instr |  O   | wire [31:0] |   D 级指令   |

信号优先级：reset > stall > flush
保证复位优先，且阻塞时不清空延迟槽

#### 1. GRF

|    信号名    | 方向 |    类型     |         描述          |
| :----------: | :--: | :---------: | :-------------------: |
|     clk      |  I   |    wire     |       时钟信号        |
|    reset     |  I   |    wire     |     同步复位信号      |
| read_number1 |  I   | wire [4:0]  |      读寄存器1号      |
| read_number2 |  I   | wire [4:0]  |      读寄存器2号      |
| write_enable |  I   |    wire     |     寄存器写使能      |
| write_number |  I   | wire [4:0]  |      写寄存器号       |
|  write_data  |  I   | wire [31:0] |     写寄存器数据      |
|      PC      |  I   | wire [31:0] |   指令地址（调试）    |
|  read_data1  |  O   | wire [31:0] | 读寄存器1数据（原始） |
|  read_data2  |  O   | wire [31:0] | 读寄存器2数据（原始） |

当写寄存器号为 0 时，替换写入数据为 0。

GRF 模块内实现 W 级向 W 级的内部转发。
当写使能为高电平、读写寄存器号相同且不为零时，用即将写入的数据替代实际读出的数据。

根据 FWD_to_D 信号，选择接受 E 级或 M 级的转发数据，透明替代 rs_data 和 rt_data

#### 2. EXT

##### （1）模块结构

|  信号名   | 方向 |    类型     |   描述   |
| :-------: | :--: | :---------: | :------: |
|  operand  |  I   | wire [31:0] |  操作数  |
| operation |  I   | wire [1:0]  | 操作类型 |
|  result   |  O   | reg [31:0]  |   结果   |

##### （2）功能描述

| operation |           功能           |
| :-------: | :----------------------: |
|    00     |          零拓展          |
|    01     |         符号拓展         |
|    10     | 加载到高 16 位，低位补 0 |

#### 3. CMP

（1）模块结构

|  信号名   | 方向 |        类型        |   描述   |
| :-------: | :--: | :----------------: | :------: |
| operand1  |  I   | wire signed [31:0] | 操作数1  |
| operand2  |  I   | wire signed [31:0] | 操作数2  |
| operation |  I   |     wire [2:0]     | 操作类型 |
|  result   |  O   |        reg         |   结果   |

##### （2）功能描述

| operation |   功能   |
| :-------: | :------: |
|    000    |   等于   |
|    001    |  不等于  |
|    010    |   小于   |
|    011    | 大于等于 |
|    100    |   大于   |
|    101    | 小于等于 |

缺省输出 1'b0。

#### 4. NPC

|       信号名       | 方向 |    类型     |        描述        |
| :----------------: | :--: | :---------: | :----------------: |
|        F_PC        |  I   | wire [31:0] |      F 级 PC       |
|        D_PC        |  I   | wire [31:0] |      D 级 PC       |
| instr_index_offset |  I   | wire [25:0] | 立即地址和偏移地址 |
|      regester      |  I   | wire [31:0] |      rs寄存器      |
|       branch       |  I   | wire [1:0]  |      分支信号      |
|        jump        |  I   | wire [1:0]  |      跳转信号      |
|     CMP_result     |  I   |    wire     |     比较器结果     |
|      next_PC       |  O   | reg [31:0]  |      下一 PC       |

不分支 / 跳转时，next_PC = F_PC + 32'd4。
需分支时，CMP_result 表示分支条件，next_PC 用 D_PC 计算。
需跳转时，next_PC 用 D_PC 计算。

### （三）E 级

DE 流水线寄存器

|    信号名    | 方向 |    类型     |          描述          |
| :----------: | :--: | :---------: | :--------------------: |
|     clk      |  I   |    wire     |        时钟信号        |
|    reset     |  I   |    wire     |      同步复位信号      |
|    stall     |  I   |    wire     |        阻塞信号        |
|    flush     |  I   |    wire     |        刷新信号        |
|   D_instr    |  I   | wire [31:0] |        D 级指令        |
|    D_PC8     |  I   | wire [31:0] |      D 级 PC + 8       |
|  D_rs_data   |  I   | wire [31:0] |     D 级 rs 寄存器     |
|  D_rt_data   |  I   | wire [31:0] |     D 级 rt 寄存器     |
| D_EXT_result |  I   | wire [31:0] |   D 级 EXT 拓展结果    |
|   E_instr    |  O   | wire [31:0] |        E 级指令        |
|    E_PC8     |  O   | wire [31:0] |      E 级 PC + 8       |
|  E_rs_data   |  O   | wire [31:0] | E 级 rs 寄存器（原始） |
|  E_rt_data   |  O   | wire [31:0] | E 级 rt 寄存器（原始） |
| E_EXT_result |  O   | wire [31:0] |   E 级 EXT 拓展结果    |

信号优先级：reset > stall > flush
保证复位优先，且阻塞时不插入 nop

根据 FWD_to_E 信号，选择接受 M 级或 W 级的转发数据，透明替代 rs_data 和 rt_data

根据指令类型，选择转发 PC + 8 或 EXT_result

#### 1. ALU

##### （1）模块结构

|  信号名   | 方向 |    类型     |   描述   |
| :-------: | :--: | :---------: | :------: |
| operand1  |  I   | wire [31:0] | 操作数1  |
| operand2  |  I   | wire [31:0] | 操作数2  |
| operation |  I   | wire [3:0]  | 操作类型 |
|  result   |  O   | reg [31:0]  | 运算结果 |

##### （2）功能描述

| operation |    功能    |
| :-------: | :--------: |
|   0000    |     加     |
|   0001    |     减     |
|   0010    |   按位与   |
|   0011    |   按位或   |
|   0100    |  按位异或  |
|   0101    |  按位或非  |
|   0110    |  逻辑左移  |
|   0111    |  逻辑右移  |
|   1000    |  算数右移  |
|   1001    | 有符号小于 |
|   1010    | 无符号小于 |

缺省输出 32‘hffffffff。

### （四）M 级

EM 流水线寄存器

|    信号名    | 方向 |    类型     |          描述          |
| :----------: | :--: | :---------: | :--------------------: |
|     clk      |  I   |    wire     |        时钟信号        |
|    reset     |  I   |    wire     |      同步复位信号      |
|    stall     |  I   |    wire     |        阻塞信号        |
|    flush     |  I   |    wire     |        刷新信号        |
|   E_instr    |  I   | wire [31:0] |        E 级指令        |
|    E_PC8     |  I   | wire [31:0] |      E 级 PC + 8       |
|  E_rt_data   |  I   | wire [31:0] |     E 级 rt 寄存器     |
| E_ALU_result |  I   | wire [31:0] |   E 级 ALU 计算结果    |
|   M_instr    |  O   | wire [31:0] |        M 级指令        |
|    M_PC8     |  O   | wire [31:0] |      M 级 PC + 8       |
|  M_rt_data   |  O   | wire [31:0] | M 级 rt 寄存器（原始） |
| M_ALU_result |  O   | wire [31:0] |   M 级 ALU 计算结果    |

信号优先级：reset > stall > flush
保证复位优先，且阻塞时不插入 nop

根据 FWD_to_M 信号，选择接受 W 级的转发数据，透明替代 rt_data

根据指令类型，选择转发 PC + 8、rt_data 或 ALU_result。

#### 1. DM

##### （1）模块结构

|   信号名   | 方向 |    类型     |       描述       |
| :--------: | :--: | :---------: | :--------------: |
|    clk     |  I   |    wire     |     时钟信号     |
|   reset    |  I   |    wire     |   同步复位信号   |
|    DMop    |  I   | wire [3:0]  |    DM操作类型    |
|    addr    |  I   | wire [31:0] |   读写内存地址   |
| write_data |  I   | wire [31:0] |    写内存数据    |
|     PC     |  I   | wire [31:0] | 指令地址（调试） |
| read_data  |  O   | wire [31:0] |    读内存数据    |

起始地址：0x00000000
地址范围：0x00000000 ~ 0x00002FFF
存储容量：$3072 * 32bit$

非法地址读取输出未定值，非法地址写入无操作。

按字操作时忽略未对齐的地址位，按半字操作时若地址未对齐则输出 32‘ffffffff。

##### （2）功能描述

| DMop |     功能     |
| :--: | :----------: |
| 0000 |     读字     |
| 0001 |     写字     |
| 0010 |    读半字    |
| 0011 |    写半字    |
| 0100 |    读字节    |
| 0101 |    写字节    |
| 0110 | 读无符号半字 |
| 1000 | 读无符号字节 |

缺省输出 32‘hffffffff。

### （五）W 级

MW 流水线寄存器

|     信号名      | 方向 |    类型     |       描述        |
| :-------------: | :--: | :---------: | :---------------: |
|       clk       |  I   |    wire     |     时钟信号      |
|      reset      |  I   |    wire     |   同步复位信号    |
|      stall      |  I   |    wire     |     阻塞信号      |
|      flush      |  I   |    wire     |     刷新信号      |
|     M_instr     |  I   | wire [31:0] |     M 级指令      |
|      M_PC8      |  I   | wire [31:0] |    M 级 PC + 8    |
|  M_ALU_result   |  I   | wire [31:0] | M 级 ALU 计算结果 |
| M_MEM_read_data |  I   | wire [31:0] |  M 级读内存数据   |
|     W_instr     |  O   | wire [31:0] |     W 级指令      |
|      W_PC8      |  O   | wire [31:0] |    W 级 PC + 8    |
|  W_ALU_result   |  O   | wire [31:0] | W 级 ALU 计算结果 |
| W_MEM_read_data |  O   | wire [31:0] |  W 级读内存数据   |

信号优先级：reset > stall > flush
保证复位优先，且阻塞时不插入 nop

转发 REG_write_data，即根据指令译码信号选择 PC + 8、rt_data 或 ALU_result。

### （六）Controller（控制器）

##### （1）整体结构

|    信号名    | 方向 |    类型    |                   描述                    |
| :----------: | :--: | :--------: | :---------------------------------------: |
| PIPELINE |  | parameter | 流水级 |
| instr  |  I   | wire [31:0] |                   指令                    |
|    Branch    |  O   |  reg [1:0]  |                 分支信号                  |
|     Jump     |  O   |  reg [1:0]  |                 跳转信号                  |
|    CMPSrc    |  O   |    reg     |          CMP 第二个操作数来源选择          |
|    CMPOp     |  O   |  reg [2:0]  |                CMP 操作类型                |
|    EXTOp     |  O   |  reg [1:0]  |                EXT 操作类型                |
|    ALUSrc    |  O   |  reg [3:0]  |             ALU 操作数来源选择             |
|    ALUOp     |  O   |  reg [3:0]  |                ALU 操作类型                |
|     DMOp     |  O   |  reg [3:0]  |                DM 操作类型                |
|    RegSrc    |  O   |  reg [1:0]  |          寄存器写入数据来源选择           |
|    RegDst    |  O   |  reg [1:0]  |          寄存器写入数据位置选择           |
|   RegWrite   |  O   |  reg  |             寄存器写允许            |
| Tuse_rs |  O   |  reg [2:0]  | 指令到达 D 级后，rs 寄存器距被使用的剩余周期 |
|   Tuse_rt    |  O   |  reg [2:0]  |   指令到达 D 级后，rt 寄存器距被使用的剩余周期   |
|     Tnew     |  O   |  reg [2:0]  |    指令到达 D 级后，距产生可写数据的剩余周期    |

##### （2）信号说明

各种操作类型已在各自模块描述。
T 型信号见后 HazardControl 部分。

**Branch**

| Branch |          跳转信号          |
| :----: | :------------------------: |
|   00   |           不跳转           |
|   01   | 低可能性跳转（保留延迟槽） |
|   10   | 高可能性跳转（清空延迟槽） |

是否链接不由此信号控制，由相关寄存器写入信号控制。

**Jump**

| Jump |     跳转信号     |
| :--: | :--------------: |
|  00  |      不跳转      |
|  01  |  跳转到立即地址  |
|  10  | 跳转到寄存器地址 |

**ALUSrc**

| ALUSrc | 第一个ALU操作数来源 | 第二个ALU操作数来源 |
| :----: | :-----------------: | :-----------------: |
|  0000  |      rs 寄存器      |      rt 寄存器      |
|  0010  |      rs 寄存器      |       立即数        |
|  0100  |      rs 寄存器      |        32'd0        |
|  0111  |      rt 寄存器      |        shamt        |
|  1001  |      rt 寄存器      |      rs 寄存器      |

**RegSrc**


| RegSrc | 寄存器写入数据来源 |
| :----: | :----------------: |
|   00   |        ALU         |
|   01   |         DM         |
|   10   |     PC + 32‘d8     |

**RegDst**

| RegDst | 寄存器写入数据位置 |
| :----: | :----------------: |
|   00   |         rt         |
|   01   |         rd         |
|   10   |     5'd31(ra)      |



### （七）HazardControl

|       信号名       | 方向 |       类型        |         描述         |
| :----------------: | :--: | :---------------: | :------------------: |
|        D_rs        |  I   |    wire [4:0]     |       D 级 rs        |
|        D_rt        |  I   |    wire [4:0]     |       D 级 rt        |
|     D_Tuse_rs      |  I   | wire signed [2:0] |     D 级 Tuse_rs     |
|     D_Tuse_rt      |  I   | wire signed [2:0] |     D 级 Tuse_rt     |
|        E_rs        |  I   |    wire [4:0]     |       E 级 rs        |
|        E_rt        |  I   |    wire [4:0]     |       E 级 rt        |
| E_REG_write_number |  I   |    wire [4:0]     |    E 级写寄存器号    |
| E_REG_write_enable |  I   |       wire        |   E 级寄存器写使能   |
|     E_Tuse_rs      |  I   | wire signed [2:0] |     E 级 Tuse_rs     |
|     E_Tuse_rt      |  I   | wire signed [2:0] |     E 级 Tuse_rt     |
|       E_Tnew       |  I   | wire signed [2:0] |      E 级 Tnew       |
|     M_Tuse_rs      |  I   | wire signed [2:0] |     M 级 Tuse_rs     |
|     M_Tuse_rt      |  I   | wire signed [2:0] |     M 级 Tuse_rt     |
|       M_Tnew       |  I   | wire signed [2:0] |      M 级 Tnew       |
|        M_rs        |  I   |    wire [4:0]     |       M 级 rs        |
|        M_rt        |  I   |    wire [4:0]     |       M 级 rt        |
| M_REG_write_number |  I   |    wire [4:0]     |    M 级写寄存器号    |
| M_REG_write_enable |  I   |       wire        |   M 级寄存器写使能   |
|     W_Tuse_rs      |  I   | wire signed [2:0] |     W 级 Tuse_rs     |
|     W_Tuse_rt      |  I   | wire signed [2:0] |     W 级 Tuse_rt     |
|       W_Tnew       |  I   | wire signed [2:0] |      W 级 Tnew       |
|        W_rs        |  I   |    wire [4:0]     |       W 级 rs        |
|        W_rt        |  I   |    wire [4:0]     |       W 级 rt        |
| W_REG_write_number |  I   |    wire [4:0]     |    W 级写寄存器号    |
| W_REG_write_enable |  I   |       wire        |   W 级寄存器写使能   |
|       stall        |  O   |       wire        |       阻塞信号       |
|    FWD_to_D_rs     |  O   |    wire [1:0]     | D 级 rs 接收转发信号 |
|    FWD_to_D_rt     |  O   |    wire [1:0]     | D 级 rt 接收转发信号 |
|    FWD_to_E_rs     |  O   |    wire [1:0]     | E 级 rs 接收转发信号 |
|    FWD_to_E_rt     |  O   |    wire [1:0]     | E 级 rt 接收转发信号 |
|    FWD_to_M_rt     |  O   |    wire [1:0]     | M 级 rt 接收转发信号 |

#### 1. 险情分析

按教程要求的 CPU 设计只可能发生数据冒险，即各级流水线读写同一寄存器。

解决数据冒险可使用 AT 法，在合适时机进行阻塞和（接受）转发。

阻塞只发生在 D 级，转发为暴力转发。

##### ① 阻塞

D 级后面的流水级判断是否阻塞 D 级。

当后执行（新）的指令需要读取先执行（旧）的指令未产生（写入流水线寄存器）的新数据（写入流水线寄存器）时发生阻塞。

##### ② 转发

W 级之前的流水级（不包括 F 级）判断如何接受转发。

先执行（旧）的指令无论新数据是否可用都一概发送转发数据。
当后执行（新）的指令一旦可以读取先执行（旧）的指令刚产生（写入流水线寄存器）的新数据，
就按优先级（DE > EM > MW）选择最新的数据接受转发数据

#### 2. HazardControl 功能

A 条件：寄存器写使能、写寄存器号不为零、读写寄存器冲突（且读寄存器不超时）

阻塞 T 条件：Tnew > Tuse

接受转发 T 条件：Tnew == 0

#### 3. T值说明

对于忽略 T 值的指令，设置为 0 其实可以发生正确的行为。
为了调试方便，逻辑清晰，使用如下设置方法。

Tuse忽略表示不读寄存器，可设置为 3，理解为读超时。
由于任何指令均有 rs 和 rt 域，CPU 会认为任何指令都在读寄存器，A 条件可能满足（可以给A条件与上此信号信息）。
但由于此时 Tnew > Tuse 不满足，故T条件不满足，不会触发阻塞。
对于 Tnew = 0 的指令，T条件满足，若A条件也满足则可能触发转发。
但由于此时不读寄存器，即使接受转发，也不会产生影响。
所以 Tuse 忽略的指令不会触发阻塞，且转发无效。

Tnew忽略表示不写寄存器，可设置为 -1，理解为已写入。
由于此时 write_enable 不满足，故A条件不满足。
由于此时 Tnew > Tuse 不满足，故T条件不满足。
所以 Tnew 忽略的指令不会触发阻塞和转发。

## 二、测试方案

### （一）课下测试

#### 1. 输入

```
341c0000
341d0000
34011010
3c028723
34037856
3c0485ff
34050001
3c06ffff
3407ffff
00220820
00234820
00224022
00e00022
13910003
00000000
10000015
00000000
10220013
00000000
3402000c
00000000
00000000
00000000
0c000c1b
ac410000
1000000b
00220820
00220820
00220820
00220820
ac5f0000
8c410000
00000000
00000000
00000000
00200008
ac5f0000
1000ffff
00000000
```

#### 2. 输出

```
                  55@00003000: $28 <= 00000000
                  65@00003004: $29 <= 00000000
                  75@00003008: $ 1 <= 00001010
                  85@0000300c: $ 2 <= 87230000
                  95@00003010: $ 3 <= 00007856
                 105@00003014: $ 4 <= 85ff0000
                 115@00003018: $ 5 <= 00000001
                 125@0000301c: $ 6 <= ffff0000
                 135@00003020: $ 7 <= 0000ffff
                 145@00003024: $ 1 <= 87231010
                 155@00003028: $ 9 <= 87238866
                 165@0000302c: $ 8 <= 00001010
                 175@00003030: $ 0 <= 0000ffff
                 225@0000304c: $ 2 <= 0000000c
                 265@0000305c: $31 <= 00003064
                 265@00003060: *0000000c <= 87231010
                 285@0000306c: $ 1 <= 8723101c
                 295@00003070: $ 1 <= 87231028
                 305@00003074: $ 1 <= 87231034
                 305@00003078: *0000000c <= 00003064
                 325@0000307c: $ 1 <= 00003064
                 365@00003090: *0000000c <= 00003064
                 395@00003068: $ 1 <= 00003070
```

### （二）自动测试

#### 1. 调试信息

```verilog
`include "../macros.v"
`timescale 1ns / 1ps

module mips_TB;
    reg clk;
    reg reset;

    mips uut (
        .clk  (clk),
        .reset(reset)
    );
`ifdef LOCAL
    integer fd;
`endif
    initial begin
        clk   = 0;
        reset = 1;
        #10 reset = 0;
`ifdef LOCAL
        fd = $fopen("info.txt", "w");
        $fwrite(fd, "                Time :     F    |     D    |     E    |     M    |     W   \n");
        $fwrite(fd, "--------------------------------------------------------------------------\n");
        $fclose(fd);
`endif
    end
    always #5 clk = ~clk;
`ifdef LOCAL
    always begin
        #10 if (!reset) begin
            fd = $fopen("info.txt", "a");
            $fwrite(fd,
            "%d : %h | %h | %h | %h | %h\n", $time, uut.F_PC, uut.D_PC, uut.E_PC, uut.M_PC, uut.W_PC);
            $fwrite(fd,
            "                     : %h | %h | %h | %h | %h\n",
            uut.F_instr, uut.D_instr, uut.E_instr, uut.M_instr, uut.W_instr);
            $fwrite(fd,
            "                                | %d %d %d | %d %d %d | %d %d %d | %d %d %d\n",
            uut.D_Tuse_rs, uut.D_Tuse_rt, uut.D_control.Tnew,
            uut.E_Tuse_rs, uut.E_Tuse_rt, uut.E_Tnew,
            uut.M_Tuse_rs, uut.M_Tuse_rt, uut.M_Tnew,
            uut.W_Tuse_rs, uut.W_Tuse_rt, uut.W_Tnew);
            $fwrite(fd,
            "S : %d ; FT_D_RS : %d ; FT_D_RT : %d ; FT_E_RS : %d ; FT_E_RT : %d ; FT_M_RT : %d\n",
             uut.stall, uut.FWD_to_D_rs, uut.FWD_to_D_rt, uut.FWD_to_E_rs, uut.FWD_to_E_rt, uut.FWD_to_M_rt);
            $fwrite(fd, "--------------------------------------------------------------------------\n");
            $fclose(fd);
        end
    end
`endif
endmodule
```

#### 2. 评测机



### （三）打包工具

来自[讨论区](http://cscore.buaa.edu.cn/#/discussion_area/1468/1791/posts)，在提交前需删除 macros.v 内的 LOCAL 宏定义

```python
import os
import zipfile
zip_filename = 'My_CPU.zip'
current_folder = os.getcwd()
with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
    for filename in os.listdir(current_folder):
        if filename.endswith('.v'):
            file_path = os.path.join(current_folder, filename)
            zipf.write(file_path, filename)
```



## 三、思考题

### （一）我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。

提前分支判断将比较操作提前到D级，导致分支指令的 D_Tuse_rs 和 D_Tuse_rt 的值均为 0。
后续指令如果满足条件，只要 Tnew > 0 （很常见）就会阻塞流水线。
这可能抵消提前判断分支带来的效率提升，甚至会降低效率。
示例如下：

```assembly
beq $t0, $t1, label
add $t0, $s0, $s1
label:
...
```
### （二）因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？

跳转指令执行后，延迟槽中的指令（地址为 PC + 4 ）被执行，而真正的下一条指令地址为 PC + 8。
返回至链接地址时，因为延迟槽中的指令已经被执行了，所以返回地址应为真正的下一条指令地址（即 PC + 8 ）
否则延迟槽中的指令将被再次执行，产生错误。所以写入的链接地址应为 PC + 8

### （三）我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？

如果转发数据来源于功能部件，接受转发的流水级的执行总延迟就会增加，从而影响整条流水线的时序，延长时钟周期，降低总效率。
实际上，如果这样做就失去了设计流水线 CPU 的意义，只是编程时以流水线的形式，最坏情况下实际的数据通路与单周期 CPU 无异。

### （四）我们为什么要使用 GPR 内部转发？该如何实现？

W 级和 D 级可能同时读写同一寄存器，而读取是组合逻辑，写入是时序逻辑，两者相差半个周期，使得 D 级读不到最新的数据，需要进行转发。
与其他部件的外部转发相比，由于GPR 部件同时拥有读写信息，故可以实现方便的内部转发。

实现方式为：当写使能、读写寄存器一致且非零时，选择WD端口的输入驱动相应输出端口，否则使用当前寄存器中的实际值。

### （五）我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？

数据的需求者需要最新的 rs_data 和 rt_data，供给者可能改变它们的值

#### 1. 需求者

D 级接受 E 级或 M 级寄存器的转发数据，用于 CMP 的两个操作数、NPC 的寄存器输入和 DE_REG
E 级接受 M 级或 W 级寄存器的转发数据，用于 ALU 两个操作数和 EM_REG
M 级接受 W 级寄存器的转发数据，用于 DM 写入数据

#### 2. 供给者

E 级寄存器转发 PC + 8 或 EXT_result，M 级寄存器转发 PC + 8 或 ALU_result，W 级寄存器转发即将写入的数据（PC + 8、ALU_result 或 MEM_read_data）

### （六）在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。

#### 1. 指令分类

寄存器立即数计算、寄存器寄存器计算、跳转「跳转目标（立即数 / 寄存器 / 内存），是否链接」、分支（根据立即数 / 寄存器 / 内存，是否清空延迟槽，是否无条件链接）、写内存、读内存（条件写寄存器）。

#### 2. 修改或扩展

Control 内拓展控制信号和执行信息。
HazardControl 内拓展阻塞条件和转发条件（主要是 A 信号，各级写寄存器数量、位置和使能可能变化）。
各部件拓展操作类型。
数据通路添加新的分支。

### （七）确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。

#### 1. 译码方式

分布式译码

#### 2. 译码器架构

在 Control 中译码控制信号，每个流水级都实例化 Control，只连接需要的端口。

#### 3. 优势

新增指令比较方便，只需在合适位置添加分支，为每种控制信号赋值，不易导致回归问题。
减少了流水线寄存器流水的信号量，降低了流水线寄存器的设计复杂度。

#### 4. 劣势

代码冗长，各类指令之间缺乏逻辑关系。
增加了需要实例化控制器的数量，加大了连线量，增加仿真时间。
