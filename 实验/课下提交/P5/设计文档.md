# Verilog MIPS 五级流水线 CPU

## 一、设计草稿

### （一）整体结构

功能模块： IFU、GRF、EXT、CMP、NPC、ALU、DM、Control 和 HazardControl
流水线寄存器：ID_REG、DE_REG、EM_REG、MW_REG

### （二）模块设计

#### 1. IFU

#### （1）整体结构

| 信号名  | 方向 |    类型    |     描述     |
| :-----: | :--: | :--------: | :----------: |
|   clk   |  I   |    wire    |   时钟信号   |
|  reset  |  I   |    wire    | 同步复位信号 |
|  stall  |  I   |    wire    |   阻塞信号   |
| next_PC |  I   | wire[31:0] | 下一指令地址 |
|   PC    |  O   | wire[31:0] | 当前指令地址 |
|  instr  |  O   | wire[31:0] |     指令     |

起始地址：0x00003000
地址范围：0x00003000 ~ 0x00006FFF
存储容量：$4096 * 32bit$

##### （2）PC

| 信号名  | 方向 |    类型    |     描述     |
| :-----: | :--: | :--------: | :----------: |
|   clk   |  I   |    wire    |   时钟信号   |
|  reset  |  I   |    wire    | 同步复位信号 |
|  stall  |  I   |    wire    |   阻塞信号   |
| next_PC |  I   | wire[31:0] | 下一指令地址 |
|   PC    |  O   | wire[31:0] | 当前指令地址 |

##### （3）IM

| 信号名 | 方向 |    类型    |   描述   |
| :----: | :--: | :--------: | :------: |
|  addr  |  I   | wire[31:0] | 指令地址 |
| instr  |  O   | wire[31:0] |   指令   |

#### 2. GRF

|    信号名    | 方向 |    类型    |       描述       |
| :----------: | :--: | :--------: | :--------------: |
|     clk      |  I   |    wire    |     时钟信号     |
|    reset     |  I   |    wire    |   同步复位信号   |
|  read_reg1   |  I   | wire[4:0]  |   读寄存器1号    |
|  read_reg2   |  I   | wire[4:0]  |   读寄存器2号    |
| write_enable |  I   |    wire    |   寄存器写使能   |
|  write_reg   |  I   | wire[4:0]  |    写寄存器号    |
|  write_data  |  I   | wire[31:0] |   写寄存器数据   |
|      PC      |  I   | wire[31:0] | 指令地址（调试） |
|  read_data1  |  O   | wire[31:0] |  读寄存器1数据   |
|  read_data2  |  O   | wire[31:0] |  读寄存器2数据   |

#### 3. ALU

##### （1）模块结构

|  信号名   | 方向 |    类型    |   描述   |
| :-------: | :--: | :--------: | :------: |
| operand1  |  I   | wire[31:0] | 操作数1  |
| operand2  |  I   | wire[31:0] | 操作数2  |
| operation |  I   | wire[3:0]  | 操作类型 |
|  result   |  O   | reg[31:0]  | 运算结果 |
|   zero    |  O   |    wire    |  零标志  |

##### （2）功能描述

| operation |    功能    |
| :-------: | :--------: |
|   0000    |     加     |
|   0001    |     减     |
|   0010    |   按位与   |
|   0011    |   按位或   |
|   0100    |  按位异或  |
|   0101    |  按位或非  |
|   0110    |  逻辑左移  |
|   0111    |  逻辑右移  |
|   1000    |  算数右移  |
|   1001    | 有符号小于 |
|   1010    | 无符号小于 |

#### 4. DM

|    信号名    | 方向 |    类型    |       描述       |
| :----------: | :--: | :--------: | :--------------: |
|     clk      |  I   |    wire    |     时钟信号     |
|    reset     |  I   |    wire    |   同步复位信号   |
| write_enable |  I   |    wire    |    内存写使能    |
|     addr     |  I   | wire[31:0] |   读写内存地址   |
|  write_data  |  I   | wire[31:0] |    写内存数据    |
|      PC      |  I   | wire[31:0] | 指令地址（调试） |
|  read_data   |  O   | wire[31:0] |    读内存数据    |

起始地址：0x00000000
地址范围：0x00000000 ~ 0x00002FFF
存储容量：$3072 * 32bit$

#### 5. EXT

##### （1）模块结构

|  信号名   | 方向 |    类型    |   描述   |
| :-------: | :--: | :--------: | :------: |
|  operand  |  I   | wire[31:0] |  操作数  |
| operation |  I   | wire[1:0]  | 操作类型 |
|  result   |  O   | reg[31:0]  |   结果   |

##### 2）功能描述

| operation |         功能          |
| :-------: | :-------------------: |
|    00     |        零拓展         |
|    01     |       符号拓展        |
|    10     | 加载到高16位，低位补0 |

#### 6. Controller（控制器）

##### （1）整体结构

|    信号名    | 方向 |    类型    |                   描述                    |
| :----------: | :--: | :--------: | :---------------------------------------: |
| instr  |  I   | wire[31:0] |                   指令                    |
|    Branch    |  O   |  reg[1:0]  |                 分支信号                  |
|     Jump     |  O   |  reg[1:0]  |                 跳转信号                  |
|    CMPSrc    |  O   |    reg     |          CMP第二个操作数来源选择          |
|    CMPOp     |  O   |  reg[2:0]  |                CMP操作类型                |
|    EXTOp     |  O   |  reg[1:0]  |                EXT操作类型                |
|    ALUSrc    |  O   |  reg[3:0]  |             ALU操作数来源选择             |
|    ALUOp     |  O   |  reg[3:0]  |                ALU操作类型                |
|     DMOp     |  O   |  reg[3:0]  |                DM操作类型                 |
|    RegSrc    |  O   |  reg[1:0]  |          寄存器写入数据来源选择           |
|    RegDst    |  O   |  reg[1:0]  |          寄存器写入数据位置选择           |
|   RegWrite   |  O   |  reg[1:0]  |             寄存器写操作类型              |
| Tuse_rs |  O   |  reg[1:0]  | 指令到达D级后，rs 距被使用的剩余周期 |
|   Tuse_rt    |  O   |  reg[1:0]  |   指令到达D级后，rt 距被使用的剩余周期    |
|     Tnew     |  O   |  reg[1:0]  |    指令到达D级后，距产生数据的剩余周期    |

##### （2）信号说明

| Branch | 跳转信号 |
| :----: | :------: |
|   00   |  不跳转  |
|   01   |  零跳转  |
|   10   | 非零跳转 |

| Jump |     跳转信号     |
| :--: | :--------------: |
|  00  |      不跳转      |
|  01  |  跳转到直接地址  |
|  10  | 跳转到寄存器地址 |

| ALUSrc | 第一个ALU操作数来源 | 第二个ALU操作数来源 |
| :----: | :-----------------: | :-----------------: |
|  0000  |      rs寄存器       |      rt寄存器       |
|  0010  |      rs寄存器       |     立即数/偏移     |
|  0100  |      rs寄存器       |        32'd0        |
|  0111  |      rt寄存器       |   s(instr[10:6])    |
|  1001  |      rt寄存器       |      rs寄存器       |


| RegSrc | 寄存器写入数据来源 |
| :----: | :----------------: |
|   00   |        ALU         |
|   01   |       Memory       |
|   10   |     PC + 32'd4     |

| RegDest | 寄存器写入数据位置 |
| :-----: | :----------------: |
|   00    |  rt(INSTR[20:16])  |
|   01    |  rd(INSTR[15:11])  |
|   10    |     5'd31(ra)      |

Tuse忽略表示不读寄存器，设置为3，可以理解为读超时。
由于任何指令均有 rs 和 rt 域，CPU 会认为任何指令都在读寄存器，A 条件可能满足（可以给A条件与上此信号信息）。
但由于此时 Tnew > Tuse 不满足，故T条件不满足，不会触发阻塞。
对于 Tnew = 0 的指令，T条件满足，若A条件也满足则可能触发转发。
但由于此时不读寄存器，即使接受转发，也不会产生影响。
所以 Tuse 忽略的指令不会触发阻塞，且转发无效。

Tnew忽略表示不写寄存器，设置为-1，可以理解为已写入。
由于此时 write_enable 不满足，故A条件不满足。
由于此时 Tnew > Tuse 不满足，故T条件不满足。
所以 Tnew 忽略的指令不会触发阻塞和转发。

## 二、测试方案

### （一）课下测试

#### 1. 输入

```
341c0000
341d0000
34011010
3c028723
34037856
3c0485ff
34050001
3c06ffff
3407ffff
00220820
00234820
00224022
00e00022
13910003
00000000
10000015
00000000
10220013
00000000
3402000c
00000000
00000000
00000000
0c000c1b
ac410000
1000000b
00220820
00220820
00220820
00220820
ac5f0000
8c410000
00000000
00000000
00000000
00200008
ac5f0000
1000ffff
00000000
```

#### 2. 输出

```
                  55@00003000: $28 <= 00000000
                  65@00003004: $29 <= 00000000
                  75@00003008: $ 1 <= 00001010
                  85@0000300c: $ 2 <= 87230000
                  95@00003010: $ 3 <= 00007856
                 105@00003014: $ 4 <= 85ff0000
                 115@00003018: $ 5 <= 00000001
                 125@0000301c: $ 6 <= ffff0000
                 135@00003020: $ 7 <= 0000ffff
                 145@00003024: $ 1 <= 87231010
                 155@00003028: $ 9 <= 87238866
                 165@0000302c: $ 8 <= 00001010
                 175@00003030: $ 0 <= 0000ffff
                 225@0000304c: $ 2 <= 0000000c
                 265@0000305c: $31 <= 00003064
                 265@00003060: *0000000c <= 87231010
                 285@0000306c: $ 1 <= 8723101c
                 295@00003070: $ 1 <= 87231028
                 305@00003074: $ 1 <= 87231034
                 305@00003078: *0000000c <= 00003064
                 325@0000307c: $ 1 <= 00003064
                 365@00003090: *0000000c <= 00003064
                 395@00003068: $ 1 <= 00003070
```

### （二）自动测试

根据讨论区内容和教程，生成测试数据，进行自动测试。由于 Win11 Bug 未果。

### （三）打包工具

来自[讨论区](http://cscore.buaa.edu.cn/#/discussion_area/1468/1791/posts)，在提交前需删除 macros.v 内的 LOCAL 宏定义

```python
import os
import zipfile
zip_filename = 'My_CPU.zip'
current_folder = os.getcwd()
with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
    for filename in os.listdir(current_folder):
        if filename.endswith('.v'):
            file_path = os.path.join(current_folder, filename)
            zipf.write(file_path, filename)
```



## 三、思考题

### （一）我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。

提前分支判断将比较操作提前到D级，这导致分支指令的 D_Tuse_rs 和 D_Tuse_rt 的值为 0，容易在 Tuse < Tnew 时阻塞流水线，可能抵消提前判断分支带来的效率提升，甚至会降低效率。
示例如下：

```assembly
beq $t0, $t1, label
add $t0, $s0, $s1
label:
...
```
### （二）因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？

跳转指令执行后，延迟槽中的指令（地址为 PC + 4 ）被执行，而真正的下一条指令地址为 PC + 8
返回至链接地址时，因为延迟槽中的指令已经被执行了，所以返回地址应为真正的下一条指令地址（即 PC + 8 ），否则延迟槽中的指令将被再次执行，产生错误。所以写入的链接地址应为 PC + 8

### （三）我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？

如果转发数据来源于功能部件，接受转发的流水级的执行总延迟就会增加，从而影响整条流水线的时序，延长时钟周期，降低总效率。
实际上，如果这样做就失去了设计流水线 CPU 的意义，只是编程时以流水线的形式，最坏情况下实际的数据通路与单周期 CPU 无异。

### （四）我们为什么要使用 GPR 内部转发？该如何实现？

W 级和 D 级可能同时读写同一寄存器，而读取是组合逻辑，写入是时序逻辑，故两者相差半个周期，使得 D 级读不到最新的数据，需要进行转发。
与其他部件的外部转发相比，由于GPR 部件同时拥有读写信息，故可以实现方便的内部转发。

实现方式为：当写使能、读写寄存器一致且非零时，选择WD端口的输入驱动相应输出端口，否则使用当前寄存器中的实际值。

### （五）我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？

数据的需求者需要最新的 rs_data 和 rt_data，供给者可能改变它们的值

#### 1. 需求者

D 级接受 E 级或 M 级寄存器的转发数据，用于 CMP 的两个操作数、NPC 的寄存器输入和 DE_REG
E 级接受 M 级或 W 级寄存器的转发数据，用于 ALU 两个操作数和 EM_REG
M 级接受 W 级寄存器的转发数据，用于 DM 写入数据

#### 2. 供给者

E 级寄存器转发 PC + 8，M 级寄存器转发 PC + 8 或 ALU_result，W 级寄存器转发即将写入的数据

### （六）在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。

#### 1. 指令分类

寄存器立即数计算、寄存器寄存器计算、跳转（跳转目标，是否链接）、分支（是否条件链接）、写内存、读内存

#### 2. 修改或扩展

Control 内拓展控制信号和执行信息
HazardControl 内拓展阻塞条件和转发信号
各级流水线寄存器处理阻塞信号
各转发 / 接受 MUX 处理转发信号
各部件拓展操作类型

### （七）确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。

#### 1. 译码方式

分布式译码

#### 2. 译码器架构

在 Control 中译码控制信号，每个流水级都实例化 Control，连接需要的端口。

#### 3. 优势

新增指令比较方便，只需在合适位置添加分支，为每种控制信号赋值，不易导致回归问题。
减少了流水线寄存器流水的信号量，降低了流水线寄存器的设计复杂度。

#### 4. 劣势

代码冗长，各类指令之间缺乏逻辑关系，不易调试。
增加了需要实例化控制器的数量，加大了连线量。
