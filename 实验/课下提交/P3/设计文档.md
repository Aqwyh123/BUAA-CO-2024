# MIPS单周期CPU设计文档
## 一、设计草稿
### （一）整体结构
### （二）模块设计
#### 1. IFU（取指令单元）
##### （1）整体结构
| 信号名 | 位宽 | 方向 | 描述 |
| :----: | :----: | :----: | :----: |
| CLK | 1 | I | 时钟信号 |
| RESET | 1 | I | 异步复位信号 |
| NEXT_PC | 32 | I | 下一指令地址 |
| PC | 32 | O | 当前指令地址 |
| INSTR | 32 | O | 指令 |

起始地址：0x00003000  
地址范围：0x00003000 ~ 0x00006FFF  
存储容量：64KB(4096 * 32bit)
##### （2）PC（程序计数器）
| 信号名 | 位宽 | 方向 | 描述 |
| :----: | :----: | :----: | :----: |
| CLK | 1 | I | 时钟信号 |
| RESET | 1 | I | 异步复位信号 |
| NEXT_PC | 32 | I | 下一指令地址 |
| PC | 32 | O | 当前指令地址 |

设计32位带范围的异步复位寄存器  
使用Register部件实现  
初值实现参考了讨论区的一篇[讨论贴](http://cscore.buaa.edu.cn/#/discussion_area/1348/1477/posts)  
当 NEXT_PC > 0x00006FFF 时同步复位至初值

##### （3）IM（指令存储器）
| 信号名 | 位宽 | 方向 | 描述 |
| :----: | :----: | :----: | :----: |
| ADDR | 32 | I | 指令地址 |
| INSTR | 32 | O | 指令 |

使用ROM部件实现  
为使 ROM 的 0 位置存储的是 PC 为 0x00003000 的指令，且存储容量为 64KB  
ADDR 减 0x00003000 后，逻辑右移2位，截取[11:0]作为 ROM 的地址输入  
地址宽度为 12 位，数据宽度为 32 位的 ROM 的存储容量恰为 $2^{12}*32bit=64$ KB
#### 2. GRF（通用寄存器组）
| 信号名 | 位宽 | 方向 | 描述 |
| :----: | :----: | :----: | :----: |
| CLK | 1 | I | 时钟信号 |
| RESET | 1 | I | 异步复位信号 |
| RA1 | 5 | I | 读寄存器1号 |
| RA2 | 5 | I | 读寄存器2号 |
| WE | 1 | I | 寄存器写使能 |
| WA | 5 | I | 写寄存器号 |
| WD | 32 | I | 写寄存器数据 |
| RD1 | 32 | O | 读寄存器1数据 |
| RD2 | 32 | O | 读寄存器2数据 |

使用 P1 GRF 模块，稍作修改电路外观  
设计 32 位带使能的异步复位寄存器  
GRF使用32个上述寄存器，使用 32 选 1 MUX 选择寄存器读出，使用 5-32 Decoder 选择寄存器写使能  
其中 0 号寄存器的输入端口接地，使其值始终保持为 0
#### 3. ALU（算术逻辑单元）
##### （1）模块结构
| 信号名 | 位宽 | 方向 | 描述 |
| :----: | :----: | :----: | :----: |
| OPD1 | 32 | I | 操作数1 |
| OPD2 | 32 | I | 操作数2 |
| OP | 4 | I | 操作类型 |
| RESULT | 32 | O | 运算结果 |
| OVER | 1 | O | 溢出标志 |

使用 Arithmetic 类组件实现  
使用 16 选 1 DMX 选择结果输出
##### （2）功能描述
| OP | 功能 |
| :----: | :----: |
| 0000 | 加 |
| 0001 | 减 |
| 0010 | 按位与 |
| 0011 | 按位或 |
| 0100 | 按位异或 |
| 0101 | 按位或非 |
| 0110 | 逻辑左移 |
| 0111 | 逻辑右移 |
| 1000 | 算数右移 |
| 1001 | 有符号小于 |
| 1010 | 无符号小于 |

参考[MIPS32 Architecture For Programmers](http://cscore.buaa.edu.cn/assets/cscore-assets/MIPS_Vol2_%E6%8C%87%E4%BB%A4%E9%9B%86_.pdf)，和 MARS Help 手册选取必须实现的算数和逻辑操作  
编写程序时，常用的其他算数和逻辑操作由伪指令实现，由编译器编译为实际指令
#### 4. DM（数据存储器）
| 信号名 | 位宽 | 方向 | 描述 |
| :----: | :----: | :----: | :----: |
| CLK | 1 | I | 时钟信号 |
| RESET | 1 | I | 异步复位信号 |
| WE | 1 | I | 内存写使能 |
| ADDR | 32 | I | 读写内存地址 |
| WD | 32 | I | 写内存数据 |
| RD | 32 | O | 读内存数据 |

起始地址：0x00000000  
地址范围：0x00000000 ~ 0x00002FFF  
存储容量（应为）：48KB(3072 * 32bit)

使用 RAM 部件实现，双端口模式  
ld端口不接引脚或接电源，防止输出高阻态  
ADDR 逻辑右移 2 位，截取[11:0]作为RAM的地址输入  
地址宽度为 12 位，数据宽度为 32 位的 RAM 的容量为$2^{12}*32bit=64$ KB

*暂未想到如何有效限制存储容量到48KB*
#### 5. EXT（扩展单元）
##### （1）模块结构
| 信号名 | 位宽 | 方向 | 描述 |
| :----: | :----: | :----: | :----: |
| OPD | 32 | I | 操作数 |
| OP | 2 | I | 操作类型 |
| RESULT | 32 | O | 结果 |

使用 Bit Extender 和 Splitter 实现  
使用 4 选 1 MUX 选择结果输出
##### （2）功能描述
| OP | 功能 |
| :----: | :----: |
| 00 | 零拓展 |
| 01 | 符号拓展 |
| 10 | 加载到高16位，低位补0 |
| 11 | 符号拓展后左移2位 |

*虽然 EXT 单元有“符号拓展后左移2位”的功能，  
但分支/跳转指令的实现并不使用EXT，而是另行计算地址偏移  
实际上，这个功能未曾用到*
#### 6. Controller（控制器）
##### （1）整体结构
###### ① 设计思路
控制器实际上是一个解码器，它将每一条机器指令解析为 CPU 各模块的控制信号

最直接的实现方法就是生成真值表，但是这样在实际操作中不具有可扩展性与易调试性。增加指令时必须重新生成真值表，非常容易产生 Bug，也不利于调试。为了使逻辑易于阅读，功能便于调试，采取指令识别和信号生成分离的方式实现。
###### ② 模块结构
| 信号名 | 位宽 | 方向 | 描述 |
| :----: | :----: | :----: | :----: |
| OP | 6 | I | 操作类型 |
| FUNC | 6 | I | 功能类型 |
| ALUSrc | 1 | O | 第二个ALU操作数来源选择 |
| RegSrc | 1 | O | 寄存器写入数据来源选择 |
| RegWrite | 1 | O | 寄存器写使能 |
| RegDest | 1 | O | 写入寄存器位置选择 |
| MemWrite | 1 | O | 内存写使能 |
| Branch | 1 | O | 分支信号 |
| Jump | 1 | O | 跳转信号 |
| EXTOp | 2 | O | EXT操作类型 |
| ALUOp | 4 | O | ALU操作类型 |
###### ③ 信号说明
| ALUSrc | 第二个ALU操作数来源 |
| :----: | :----: |
| 0 | rt |
| 1 | immediate / offset |

| RegSrc | 寄存器写入数据来源 |
| :----: | :----: |
| 0 | ALU |
| 1 | Memory |

| RegDest | 写入寄存器位置选择 |
| :----: | :----: |
| 0 | rt |
| 1 | rd |
##### （2）指令识别
| 信号名 | 位宽 | 方向 | 描述 |
| :----: | :----: | :----: | :----: |
| OP | 6 | I | 操作类型 |
| FUNC | 6 | I | 功能类型 |
| *** | 1 | O | ***指令信号|
……
| *** | 1 | O | ***指令信号|

使用 Comparator 组件实现  
需要识别哪些指令就增加哪种指令信号的输出端口  
由于 Constant 默认显示十六进制，而[MIPS-C指令集](http://cscore.buaa.edu.cn/assets/cscore-assets/MIPS-C%E6%8C%87%E4%BB%A4%E9%9B%86_%E6%A0%A1%E5%AF%B9%E5%AE%8C%E6%88%90%E7%89%88_-%E6%8C%87%E4%BB%A4%E6%8E%92%E5%BA%8F.pdf)所示指令为二进制，故连接 Probe 以便调试  
##### （3）信号生成
| 信号名 | 位宽 | 方向 | 描述 |
| :----: | :----: | :----: | :----: |
| *** | 1 | I | ***指令信号|
……
| *** | 1 | I | ***指令信号|
| ALUSrc | 1 | O | 第二个ALU操作数来源选择 |
| RegSrc | 1 | O | 寄存器写入数据来源选择 |
| RegWrite | 1 | O | 寄存器写使能 |
| RegDest | 1 | O | 写入寄存器位置选择 |
| MemWrite | 1 | O | 内存写使能 |
| Branch | 1 | O | 分支信号 |
| Jump | 1 | O | 跳转信号 |
| EXTOp | 1 | O | EXT操作类型 |
| ALUOp | 1 | O | ALU操作类型 |

参考[MIPS-C指令集](http://cscore.buaa.edu.cn/assets/cscore-assets/MIPS-C%E6%8C%87%E4%BB%A4%E9%9B%86_%E6%A0%A1%E5%AF%B9%E5%AE%8C%E6%88%90%E7%89%88_-%E6%8C%87%E4%BB%A4%E6%8E%92%E5%BA%8F.pdf)中指令的RTL语言，判断指令与信号的对应关系，画出真值表

## 二、测试方案
## 三、思考题
### （一）单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能?
### （二）IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？请给出分析。若有改进意见也请一并给出。
### （三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是，请给出介绍和设计的思路。
### （四）实现 nop 空指令，并不需要将它加入控制信号真值表，为什么？
### （五）阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。